from message_class import message
from msg_generator import msg_generator, _msg_name_str, _msg_type_str

class python_generator:
    def __init__(self):
        self.pythonString = '# Auto Generated by ASN1toROS2 tool\n'
        self.indent = 0
        self.recursivecounter = 0

    def generate(self, messages, msgconvtogenerate):
        self.messages = messages
        # create NULL msg:
        self.add('from v2x_cohdainterfaces.msg import *')
        self.recursivecodegen(msgconvtogenerate)

        pyFile = open('generated.py', 'x')
        pyFile.write(self.pythonString)
        pyFile.close()

        print('called recursivecodegen() method ' + str(self.recursivecounter) + ' times total.')

    def recursivecodegen(self, msgtogenerate):
        self.recursivecounter = self.recursivecounter + 1
        # find the message in the list of messages.
        mymessage = None
        for e in self.messages:
            if msgtogenerate == e.name:
                mymessage = e
                break
        if mymessage == None:
            print(msgtogenerate + ' generation has failed.')
            print(mymessage)
            return
        # create a newline
        self.add()
        # create the message function header
        self.add('def ' + mymessage.name + '(mydata):')
        self.dentin()
        # start with content:
        todoList = list()

        # add comments
        self.add('# ' + mymessage.name.capitalize() + ".msg")
        self.add('# original asn1 type: ' + str(mymessage.type))
        self.add()
        self.add('msg = ' + _msg_type_str(msgtogenerate) + '()')

        # create contents:
        if (mymessage.type == 'SEQUENCE') or (mymessage.type == 'CHOICE'):
            for e in mymessage.contentsList:
                if not e:
                    continue
                e = e[0]
                callfunction = e[mymessage._pos_type]
                jsonvarname = _msg_name_str(e[mymessage._pos_variable])
                if e[mymessage._pos_variable] == 'COMPONENTS':
                    # TBD
                    continue
                # check if its a known type:
                if e[mymessage._pos_type] in msg_generator.convertibletypes:
                    self.add('if mydata.get("' + e[mymessage._pos_variable] + '"):')
                    self.dentin()
                    self.add('msg.' + jsonvarname + ' = mydata.' + e[mymessage._pos_variable])
                    self.dentout()
                    continue
                if e[mymessage._pos_type] == 'SEQUENCE':
                    # TBD
                    continue
                self.add('if mydata.get("' + e[mymessage._pos_variable] + '"):')
                self.dentin()
                self.add('msg.' + jsonvarname + ' = ' + callfunction + '(mydata.get("' + e[mymessage._pos_variable] + '"))')
                todoList.append(callfunction)
                self.dentout()
        elif (mymessage.type == 'SEQUENCEOF'):
            # TBD
            pass
        elif (mymessage.type == 'IA5String') or (mymessage.type == 'UTF8String') or (mymessage.type == 'NumericString') or (mymessage.type == 'ENUMERATED') or (mymessage.type == 'INTEGER') or (mymessage.type == 'BOOLEAN'):
            self.add('msg.' + _msg_name_str(mymessage.name) + ' = mydata')
            pass
        elif (mymessage.type == 'BIT STRING'):
            # TBD
            pass
        elif (mymessage.type == 'CLASS'):
            # TBD
            pass
        elif (mymessage.type == 'OCTET'):
            # TBD
            pass
        elif (mymessage.type == ''):
            # TBD
            pass
        else:
            # TBD: look for type in asndef
            pass
                    
        
        # end of function
        self.add()
        self.add('return msg')
        self.dentout()
        # recursive call:
        for e in todoList:
            self.recursivecodegen(e)
            pass
        print(mymessage.name)
        return

    def add(self, tobeadded='', end='\n'):
        startstr = ''
        start = self.indent
        while(start):
            startstr = startstr + '\t'
            start = start - 1
        self.pythonString = self.pythonString + startstr + tobeadded + end

    def dentin(self):
        self.indent = self.indent + 1
    
    def dentout(self):
        if self.indent > 0:
            self.indent = self.indent - 1
        else:
            print('Cannot dent out.')
            raise Exception()