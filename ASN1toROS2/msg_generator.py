from message_class import message
import re

class msg_generator:

    convertibletypes = {"IA5String": 'string', "UTF8String": 'string', 'INTEGER': 'int32', 'BOOLEAN' : 'uint8', 'NULL': 'Null' }
    
    knowntypes = list(('SEQUENCE', 'SEQUENCEOF', 'CHOICE', 'NULL', 'ABSENT', 'ENUMERATED'))

    def __init__(self):
        pass

    def generate(self, messages):
        failedMessages = 0
        # create NULL msg:
        nullMsgString = '# Null.msg\n'
        nullMsgString = nullMsgString + '# Auto Generated by ASN1toROS2 tool\n'
        nullMsgString = nullMsgString + '# original asn1 type: NULL'
        msgFile = open('msg/Null.msg', 'x')
        msgFile.write(nullMsgString)
        msgFile.close()
        del nullMsgString

        for msg in messages:
            # create Header
            msgString = '# ' + msg.name.capitalize() + ".msg\n"
            msgString = msgString + '# Auto Generated by ASN1toROS2 tool\n'
            msgString = msgString + '# original asn1 type: ' + str(msg.type) + '\n\n'

            # edge case: ComputedLane (not genericly handled, because its the only 
            # occasion where CHOICE is inside of a SEQUENCE definition.)
            if _msg_type_str(msg.name) == 'Computedlane':
                msgString = msgString + 'Laneid referencelaneid\n'
                msgString = msgString + 'Drivenlineoffsetsm[] offsetxaxissmall\n'
                msgString = msgString + 'Drivenlineoffsetlg[] offsetxaxislarge\n'
                msgString = msgString + 'Drivenlineoffsetsm[] offsetyaxissmall\n'
                msgString = msgString + 'Drivenlineoffsetlg[] offsetyaxislarge\n'
                msgString = msgString + 'Angle rotatexy\n'
                msgString = msgString + 'Scaleb12 scalexaxis\n'
                msgString = msgString + 'Scaleb12 scaleyaxis\n'
                msgString = msgString + 'Regionalextension[] regional\n'

            # create contents:
            elif (msg.type == 'SEQUENCE'):
                for e in msg.contentsList:
                    if not e:
                        continue
                    e = e[0]
                    if e[msg._pos_variable] == 'COMPONENTS':
                        continue
                    # check if its a known type:
                    if e[msg._pos_type] in self.convertibletypes:
                        msgString = msgString + _msg_type_str(self.convertibletypes[e[msg._pos_type]]) + ' ' + _msg_name_str(e[msg._pos_variable]) + '\n'
                        continue
                    # 
                    if e[msg._pos_type] == 'SEQUENCE':
                        regex = re.compile('(OF)(\s)+([-a-zA-Z0-9]*)')
                        ofType = regex.findall(e[msg._pos_trailer])
                        msgString = msgString + _msg_type_str(ofType[0][2]) + '[] ' + _msg_name_str(e[msg._pos_variable]) + '\n'
                        continue
                    msgString = msgString + _msg_type_str(e[msg._pos_type]) + ' ' + _msg_name_str(e[msg._pos_variable]) + '\n'
            elif (msg.type == 'CHOICE'):
                # difference to sequence: every choice is a list with length 0...1
                for e in msg.contentsList:
                    if not e:
                        continue
                    e = e[0]
                    # check if its a known type:
                    if e[msg._pos_type] in self.convertibletypes:
                        msgString = msgString + _msg_type_str(self.convertibletypes[e[msg._pos_type]]) + ' ' + _msg_name_str(e[msg._pos_variable]) + '\n'
                        continue
                    # 
                    if e[msg._pos_type] == 'SEQUENCE':
                        regex = re.compile('(OF)(\s)+([-a-zA-Z0-9]*)')
                        ofType = regex.findall(e[msg._pos_trailer])
                        msgString = msgString + _msg_type_str(ofType[0][2]) + '[] ' + _msg_name_str(e[msg._pos_variable]) + '\n'
                        continue
                    msgString = msgString + _msg_type_str(e[msg._pos_type]) + '[] ' + _msg_name_str(e[msg._pos_variable]) + '\n'
            elif (msg.type == 'SEQUENCEOF'):
                msgString = msgString + _msg_type_str(msg.sequenceof) + '[] ' + _msg_name_str(msg.name) + '\n'
            elif (msg.type == 'INTEGER'):
                msgString = msgString + 'int64 ' + _msg_name_str(msg.name) + '\n'
            elif (msg.type == 'IA5String') or (msg.type == 'UTF8String') or (msg.type == 'NumericString') or (msg.type == 'ENUMERATED'):
                msgString = msgString + 'string ' + _msg_name_str(msg.name) + '\n'
            elif (msg.type == 'BOOLEAN'):
                msgString = msgString + 'uint8 ' + _msg_name_str(msg.name) + '\n'
            elif (msg.type == 'BIT STRING'):
                msgString = msgString + 'uint8[] ' + _msg_name_str(msg.name) + '\n'
            elif (msg.type == 'CLASS'):
                # TBD
                pass
            elif (msg.type == 'OCTET'):
                msgString = msgString + 'uint16[] ' + _msg_name_str(msg.name) + '\n'
            elif (msg.type == ''):
                # TBD
                pass
            else:
                # TBD: look for type in asndef
                pass
                        
            # create new file:
            try:
                msgFile = open('msg/' + _msg_type_str(msg.name) + '.msg', 'x')
                msgFile.write(msgString)
                msgFile.close()
            except FileExistsError as e:
                failedMessages = failedMessages + 1
                print('failed due to FileExistsError:   ' + _msg_type_str(msg.name))
        print(str(failedMessages) + ' Messages of ' + str(len(messages)) + ' have failed.')

def _msg_type_str(msgtoconvert):
    # Converts the message types to strings according to msg spec
    if msgtoconvert in msg_generator.convertibletypes.values():
        return msgtoconvert
    returnmsg = msgtoconvert.lower().capitalize().replace('-', '')
    if returnmsg == 'class':
        return 'classtype'
    else:
        return returnmsg

def _msg_name_str(msgtoconvert):
    # Converts the message names to strings according to msg spec
    returnmsg = msgtoconvert.lower().replace('-', '_')
    if returnmsg == 'class':
        return 'classname'
    elif returnmsg == 'long':
        return 'lon'
    else:
        return returnmsg